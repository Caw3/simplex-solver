#!/usr/bin/env python

import argparse
import sys
import unittest
from typing import Any

import numpy as np
from scipy.optimize import linprog


# Parse Matrix Ax = b of size (n+1) x m, Vector c of size n.
def parse_command_line_args():
    parser = argparse.ArgumentParser(
        description="Read matrix A, vectors b and c from the command line.")

    parser.add_argument("-A", "--matrix_A", type=str, required=True,
                        help="Matrix A in the format '1 2 3; 4 5 6; 7 8 9'")
    parser.add_argument("-b", "--vector_b", type=str,
                        required=True, help="Vector b in the format '1 2 3'")
    parser.add_argument("-c", "--vector_c", type=str,
                        required=True, help="Vector c in the format '1 2 3'")
    parser.add_argument("--checker", help="Check output with scipy",
                        action="store_true", required=False)
    parser.add_argument("-v", "--verbose", help="print steps",
                        action="store_true", required=False)
    parser.add_argument("--test", help="Run unit tests",
                        action="store_true", required=False)
    args = parser.parse_args()
    return args


# TODO: when 0... is not a BFS
def solve(A, b, c, verbose):
    n = len(A) + 1
    m = len(A[0]) + len(b) + 1
    T = np.zeros((n, m), dtype=float)

    for i in range(len(A)):
        for j in range(len(A[0])):
            T[i][j] = A[i][j]

    for i in range(len(A[0])):
        T[i][len(A[0]) + i] = 1

    for i in range(len(b)):
        T[i][len(A[0]) + len(b)] = b[i]

    for i in range(len(c)):
        T[len(A)][i] = -c[i]

    if verbose:
        print('\n', T, '\n')

    tolerance = 1e-9
    curr_iter = 0
    while True:
        curr_iter = curr_iter + 1
        T_z = T[n - 1][0:m - 1]

        has_negative_z = any(
            map(lambda x: True if x < -tolerance else False, T_z))
        if not has_negative_z:
            break

        if curr_iter >= 10000:
            if verbose:
                print("Max iterations reached")
            return (None, None)

        pivot_col_i = find_enter_variable(T_z)
        pivot_row_i = find_exit_variable(T, pivot_col_i, b)

        if pivot_row_i is None:
            if verbose:
                print("No Feasible Solution")
            return (None, None)

        pivot_elem = T[pivot_row_i][pivot_col_i]
        assert pivot_elem != 0
        T[pivot_row_i] = T[pivot_row_i] / pivot_elem

        if verbose:
            print("Pivot element (row, col): " +
                  str((pivot_row_i, pivot_col_i)))
            print('R_' + str(pivot_row_i) + ' / ' +
                  str(pivot_elem) + ' -> R_' + str(pivot_row_i))

        for i, row in enumerate(T):
            if i == pivot_row_i or abs(T[i][pivot_col_i]) <= tolerance:
                continue
            else:
                if verbose:
                    print('-R_' + str(pivot_row_i) + ' * ' +
                          str(T[i][pivot_col_i]) + ' + ' + 'R_' + str(i) + ' -> R_' + str(i))
                T[i] = T[i] - (T[pivot_row_i] * T[i][pivot_col_i])

        if verbose:
            print('\n', T, '\n')

    result = np.zeros(len(c), dtype=float)
    for j in range(len(c)):
        (is_basic, row_i_one) = is_basic_variable(T, j)
        if is_basic:
            result[j] = T[row_i_one][-1] if abs(T[row_i_one]
                                                [-1]) > tolerance else 0.0

    return (list(result), T[-1][-1])


def find_enter_variable(T_z):
    def get_max_abs(x):
        return abs(x) if x < 0 else 0

    abs_values = map(get_max_abs, T_z)
    enumerated_values = list((v, i) for i, v in enumerate(abs_values))

    pivot_col_i = None
    for value, index in sorted(enumerated_values, key=lambda x: (-x[0], x[1])):
        if value > 0:
            pivot_col_i = index
            break

    return pivot_col_i


def find_exit_variable(T, pivot_col_i, b, tolerance=1e-9):
    curr_min = None
    pivot_row_i = None
    for i in range(len(b)):
        rhs = T[i][-1]
        elem = T[i][pivot_col_i]
        if elem <= tolerance:
            continue
        ratio = rhs / elem
        if (pivot_row_i is None) or (curr_min is None) or (ratio <= curr_min):
            curr_min = ratio
            pivot_row_i = i
    return pivot_row_i


def is_basic_variable(T, j):
    num_zeros = 0
    num_ones = 0
    row_i_one = None
    for i in range(len(T)):
        if T[i][j] == 0:
            num_zeros = num_zeros + 1
        if T[i][j] == 1:
            num_ones = num_ones + 1
            row_i_one = i

    return (True, row_i_one) if (num_zeros == len(T) - 1) and (num_ones == 1) else (False, None)


class TestLP(unittest.TestCase):
    def assertLP(self, A, b, c):
        print(
            '\n---------------------------------------------------------------------------')
        result = solve(A, b, c, verbose=True)
        expected = linprog(-c, A_ub=A, b_ub=b)
        self.assertEqual(result[1], -expected.fun)
        print(result)
        print(list(expected.x), -expected.fun)
        self.assertEqual(np.sum(c * result[0]), result[1])
        self.assertEqual(np.sum(c * result[0]), -expected.fun)

    def test_sanity(self):
        A = np.array([[4, 2], [2, 3]])
        b = np.array([32, 24])
        c = np.array([5, 4])
        self.assertLP(A, b, c)

    def test_sanity_1(self):
        A = np.array([[1, 1], [1, 2], [4, 3]])
        b = np.array([10, 15, 38])
        c = np.array([750, 1000])
        self.assertLP(A, b, c)

    def test_multiple_sol(self):
        A = np.array([[1, 1, 0], [0, 1, 3], [2, 5, 9]])
        b = np.array([2, 3, 10])
        c = np.array([1, 2, 3])
        self.assertLP(A, b, c)

    def test_no_init_bfs(self):
        A = np.array([[-1, -2], [-1, 2], [-1, 2]])
        b = np.array([-3, -1, 2])
        c = np.array([1, 3])
        res = solve(A, b, c, verbose=True)
        self.assertEqual(res[0], None)
        self.assertEqual(res[1], None)

    # def test_unbounded_solution(self):
    #     A = np.array([[1, 1], [-1, 0], [0, -1]])
    #     b = np.array([2, 0, 0])
    #     c = np.array([1, 1])
    #     res = solve(A, b, c, verbose=True)
    #     self.assertEqual(res[0], None)  # No bounded solution for maximization
    #     self.assertEqual(res[1], None)  # Optimal value should be infinite

    def test_single_constraint(self):
        A = np.array([[1, 2]])
        b = np.array([4])
        c = np.array([2, 1])
        self.assertLP(A, b, c)

    # def test_infeasible(self):
    #     A = np.array([[1, 1], [-1, -1], [1, -1]])
    #     b = np.array([1, -2, 0])
    #     c = np.array([1, 1])
    #     res = solve(A, b, c, verbose=True)
    #     self.assertEqual(res[0], None)
    #     self.assertEqual(res[1], None)

    def test_trivial(self):
        A = np.array([[1, 0], [0, 1]])
        b = np.array([1, 1])
        c = np.array([1, 1])
        self.assertLP(A, b, c)

    def test_tight_constraints(self):
        A = np.array([[1, 1], [1, -1]])
        b = np.array([1, 0])
        c = np.array([1, 1])
        self.assertLP(A, b, c)

    def test_zero_objective(self):
        A = np.array([[1, 2], [2, 3]])
        b = np.array([4, 7])
        c = np.array([0, 0])
        self.assertLP(A, b, c)

    # def test_negative_coefficients(self):
    #     A = np.array([[-1, 2], [2, -3]])
    #     b = np.array([-1, 4])
    #     c = np.array([-1, -2])
    #     self.assertLP(A, b, c)


if __name__ == "__main__":
    np.set_printoptions(precision=3, suppress=True)

    if len(sys.argv) > 1 and sys.argv[1] == '--test':
        del sys.argv[1]
        unittest.main()
        exit()

    args = parse_command_line_args()
    A = np.array([list(map(float, row.split()))
                  for row in args.matrix_A.strip().split(';')])
    b = np.array(list(map(float, args.vector_b.strip().split())))
    c = np.array(list(map(float, args.vector_c.strip().split())))
    sol = solve(A, b, c, args.verbose)
    print(sol)

    if args.checker:
        expected = linprog(-c, A_ub=A, b_ub=b)
        print((list(expected.x), -expected.fun))
